-- NOTES --

"crc"s are crc-32s as in ZMODEM, PKZIP, Ethernet, etc

-- OVERVIEW --

filesystem (ext4, hfs+, ntfs, etc)
    implemented by the kernel at hand

block device (nbd, iSCSI, ATAoE, etc)
    nbd allows linux access and is easy to code

remapper
    maps a set of virtual fixed size zeroed block devices onto a
    single one-ended data store.

    try: use a block map list at the start of the datastore. when a
         larger mapping space is required, remap the blocks nearest to
         the block map list until there's enough space.
    try: use medium block sizes (~32KiB)

distributor
    maps a one-ended data store into a set of files or disks

    handles disk failures (total and byte-wise)

    try: map lazily, in large (>=64MiB) chunks
    try: keep mapping data on all disks
    try: allow parameterization of the RS codes to be independent of
         the disks by allocating horizontal arrays of RS-joined chunks
         on appropriate disks, rather than all disks at the same time.
    try: use a crc-32 for finding read failures

    want: configurationless restarts by storing the configuration on
          all storage drives
    want: atomic writes. maybe this isn't needed if we're careful
          about flushing.
    want: automatic rebalancing.
    want: background hash verification to actively remove bad bits


-- REMAPPER DATA STRUCTURES --

block size must be at least 4KiB
all notable structures are aligned to the block size
it is expected that the initial implementation will require the
    ordering header < partition table < jump table < data, even
    though this is not required by the on-disk format.

the jump table marks locations in multiples of the block size from
    the start of the device.

the blowfish encryption is slightly modified:
    the input password is first hashed through sha-512, then that is
    used as the input to the blowfish key schedule.

    for encryption/decryption, the plaintext is xored with the byte
    offset of the section to be encrypted wrt the start of the
    partition (to avoid pattern leaks) and also the first half of the
    uuid (to avoid cross-partition matching).

header:
    magic number "REMAPPER"
    block size in bytes (be32)
    number of blocks (be64)
    block offset of partition information (be64) (typically 1)
    block offset of jump table (be64) (typically 2)
    next free block index (be64)

partition information:
    magic number "PARTTBLS"
    number of partitions (be32)
    for each partition:
        name (be16 length prefixed string, no nulls)
        flags (be32)
            bit 0: encrypted, modified blowfish as above
            all other bits reserved, should be 0
        length in bytes (must be a multiple of the block size) (be64)
        created timestamp (be64 from epoch)
        reshaped timestamp (be64 from epoch)
        uuid (128 bits)
        number of block extents (be16)
        for each block extent:
            start block (be64)
            end block (inclusive) (be64)
            length in blocks (be64)

jump table:
    magic number "JUMPTBLS"
    for each block in the remapped world:
        block location in mapper blocks (be64, 0 if unmapped)

-- DISTRIBUTOR DATA STRUCTURES --

"file" without qualification refers to a single backing representing
    the space to be used by a single disk. it may be a file on an
    existing filesystem, for the purposes of using the free space
    on that drive, or it may be a block device, such as a raw disk or
    partition.

"chunk" refers to a contiguous area of the virtual device. they may
    vary in size depending on the geometry of the redundancy, but
    they are always a multiple of 64MiB in size.

"slice" refers to a contiguous area of a file, representing a part
    of a chunk. precisely 64MiB at all times.

"set" refers to a group of files that, when used together in a
    distributor, allow access to a one-ended store.

there are four copies of the header; all are supposed to be identical,
    but during updates of the header, they may not be. in this case,
    the valid copy with the largest rewrite index is used as the
    drive's header, and the other copies are replaced on startup.

similar with the slice info tables.

the four headers are at byte offsets 0, 128KiB, 256KiB, and 384KiB.

a slice info table exists at offset 512KiB, and lasts for
    (32 + 28 * max_slices) bytes, rounded up to the nearest multiple
    of 4KiB. following the first slice info table (and its padding) is
    a second copy of the slice info table, with the same padding.

the crc table exists after the slice info tables (including their
    alignment padding.) it lasts for
    (8 + 4 * (maximum number of slices / (64*1024*1024/4096))) bytes.

the first block data exists after the crc table, with its first
    offset rounded up to the nearest multiple of 64MiB.

the "mapped index" defines the ordering in the upper layer of the data
    stored here. mapped index 0 is first. all mapped indicies to the
    maximum mapped index in the header defines how many there are.
    note that without further information (in the slice info table),
    it is impossible to tell the size of the one-sided store.

redundancy method constants:
    0 -> plain mirror (a la raid 1)
        requires reqwidth = 1
    1 -> last is xor of the others (a la raid 5)
        requires reqwidth = width - 1
    2 -> reed-solomon in GF(2^8)
        requires width < 255.
    3 -> no redundancy
        requires reqwidth = width
    all other values reserved.

failure management:
    under partial failures of the header:
        the crc remains incorrect, the other header locations are
        used, until there are no working ones, at which point the
        entire drive is considered failed.

    under partial failures of the slice info tables:
        the other slice info table is used until there are no working
        ones, at which point the entire drive is considered failed.

    under failure of a single block of data:
        it is reconstructed (if possible) from the other locations,
        the UBE count is incremented for the file, the data slice, and
        the crc slice.  then the data is rewritten to disk and
        verified. if it fails a second time immediately following the
        rewrite, the entire slice containing the incorrect data is
        considered failed, and may be rebuilt in another location.

    if at any point the UBE count for the file exceeds its maximum,
        the file is considered entirely failed.

    if at any point the UBE count for a slice exceeds its maximum,
        the slice is considered failed and may be rebuilt in another
        location.

    under failures of the crc blocks:
        these cause errors to be detected in the slices themselves,
        and will fail until remapped to another physical location on
        disk, thus using different crc locations. failures specific
        to the crc blocks are not handled specially.

the crc table has all the data for every usable physical location in
    the file starting with the first block used as a slice. crc
    locations corresponding to unused slices may have any data in
    them, and are initialized when the slice is allocated.

header:
    magic number "DISTRIB0"
    crc checksum of the rest of the header (be32)

    [set-wide section]
    uuid for this set (128 bits)
    rewrite index (be32)
    preferred chunk width (be16)
    preferred chunk width required (be16)
    this set's human name (be16 length prefixed string, no nulls)
    number of files in set (be32)
    for each file: (including this one)
        the file's last known access specification (be16 length
            prefixed string, no nulls)
        uuid for that file (128 bits)

    [file-wide section]
    uuid for this file (128 bits)
    maximum mapped index (be64)
    maximum slices in this file (be64)
    failed slices (be32)
    maximum failed slices (be32)
    total UBE count (be32)
    maximum UBE count (be32)

slice info table:
    magic number "SLICENFO"
    crc checksum of the rest of the slice info table (be32)
    rewrite index (be32)
    maximum size in slices (be64)
    slices used (be64)
    for each slice:
        mapped index (be64)
        chunk width total (be16)
        chunk width required for proper retrieval (be16)
        this slice's index in the chunk (be16)
        redundancy method (be16)
        UBE count (be32)
        maximum UBE count (be32)
        flags (be32)
            bit 0: slice failed
            all other bits reserved, should be 0

crc table:
    magic number "CRCTABLE"
    for each 4kb chunk of slice data (see above):
        4 byte crc of the data.
